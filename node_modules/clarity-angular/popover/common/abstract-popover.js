/*
 * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { ElementRef, HostBinding, Injectable, Injector, Renderer2, SkipSelf } from "@angular/core";
import { IfOpenService } from "../../utils/conditional/if-open.service";
import { Popover } from "./popover";
// Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
var AbstractPopover = (function () {
    function AbstractPopover(injector, parentHost) {
        var _this = this;
        this.parentHost = parentHost;
        this.updateAnchor = false;
        this.popoverOptions = {};
        /*
         * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
         * a separate directive on the host. So let's do dirty but performant for now.
         */
        this.closeOnOutsideClick = false;
        this.el = injector.get(ElementRef);
        this.ifOpenService = injector.get(IfOpenService);
        this.renderer = injector.get(Renderer2);
        // Default anchor is the parent host
        this.anchorElem = parentHost.nativeElement;
        this.popoverInstance = new Popover(this.el.nativeElement);
        this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
            change ? _this.anchor() : _this.release();
        });
        if (this.ifOpenService.open) {
            this.anchor();
        }
    }
    AbstractPopover.prototype.anchor = function () {
        this.updateAnchor = true;
        // Ugh
        this.ignore = this.ifOpenService.originalEvent;
    };
    AbstractPopover.prototype.release = function () {
        this.detachOutsideClickListener();
        this.popoverInstance.release();
    };
    AbstractPopover.prototype.ngAfterViewChecked = function () {
        var _this = this;
        if (this.updateAnchor) {
            this.updateAnchor = false;
            this.popoverInstance.anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                .subscribe(function () {
                // if a scroll event is detected, close the popover
                _this.ifOpenService.open = false;
            });
            this.attachOutsideClickListener();
        }
    };
    AbstractPopover.prototype.ngOnDestroy = function () {
        this.release();
        this.subscription.unsubscribe();
    };
    Object.defineProperty(AbstractPopover.prototype, "hidden", {
        /*
         * Fallback to hide when *clrIfOpen is not being used
         */
        get: function () {
            return this.ifOpenService.open ? "visible" : "hidden";
        },
        enumerable: true,
        configurable: true
    });
    AbstractPopover.prototype.attachOutsideClickListener = function () {
        var _this = this;
        if (this.closeOnOutsideClick) {
            this.hostListener = this.renderer.listen(this.el.nativeElement, "click", function (event) { return _this.ignore = event; });
            this.documentListener = this.renderer.listen("document", "click", function (event) {
                if (event === _this.ignore) {
                    delete _this.ignore;
                }
                else {
                    _this.ifOpenService.open = false;
                }
            });
        }
    };
    AbstractPopover.prototype.detachOutsideClickListener = function () {
        if (this.closeOnOutsideClick) {
            if (this.hostListener) {
                this.hostListener();
                delete this.hostListener;
            }
            if (this.documentListener) {
                this.documentListener();
                delete this.documentListener;
            }
        }
    };
    return AbstractPopover;
}());
export { AbstractPopover };
AbstractPopover.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AbstractPopover.ctorParameters = function () { return [
    { type: Injector, },
    { type: ElementRef, decorators: [{ type: SkipSelf },] },
]; };
AbstractPopover.propDecorators = {
    'hidden': [{ type: HostBinding, args: ["style.visibility",] },],
};
//# sourceMappingURL=abstract-popover.js.map