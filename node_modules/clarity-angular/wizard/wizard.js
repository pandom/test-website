/*
 * Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChildren, Input, Output, EventEmitter, IterableDiffers, ElementRef } from "@angular/core";
import { WizardPage } from "./wizard-page";
import { WizardHeaderAction } from "./wizard-header-action";
import { GHOST_PAGE_ANIMATION } from "../modal/utils/ghost-page-animations";
// providers
import { WizardNavigationService } from "./providers/wizard-navigation";
import { PageCollectionService } from "./providers/page-collection";
import { ButtonHubService } from "./providers/button-hub";
import { HeaderActionService } from "./providers/header-actions";
var Wizard = (function () {
    function Wizard(navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
        var _this = this;
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        this.headerActionService = headerActionService;
        this.elementRef = elementRef;
        this.differs = differs;
        // LEGACY: Naming convention matches old wizard
        this.size = "xl"; // xl is the default size
        // can activate showing or hiding the ghost page effect
        // defaults to false
        this.showGhostPages = false;
        // Variable that toggles open/close of the wizard component.
        // LEGACY: Naming convention matches old wizard
        this.closable = true;
        // Variable that toggles open/close of the wizard component.
        // LEGACY: Naming convention matches old wizard
        this._open = false;
        // TODOCUMENT: HERE IS HOW THE TWO-WAY BINDING HAPPENS...
        // <clr-wizard [(clrWizardOpen)]="something"...?
        // <clr-wizard [clrWizardOpen]="something" (clrWizardOpenChange)="doSomehtign($event)" ...?
        // TOBREAK: THIS WAS CHANGED FROM "OPENCHANGED" TO "OPENCHANGE"
        // EventEmitter which is emitted on open/close of the wizard.
        this._openChanged = new EventEmitter(false);
        // User can bind his event handler for onCancel of the main content
        // LEGACY: Naming convention matches old wizard
        this.onCancel = new EventEmitter(false);
        // done
        this.wizardFinished = new EventEmitter(false);
        this.onReset = new EventEmitter(false);
        // done
        this.currentPageChanged = new EventEmitter(false);
        this.onMoveNext = new EventEmitter(false);
        this.onMovePrevious = new EventEmitter(false);
        this.stopNext = false;
        this.stopCancel = false;
        this._stopModalAnimations = false;
        this.goNextSubscription = this.navService.movedToNextPage.subscribe(function () {
            _this.onMoveNext.emit();
        });
        this.goPreviousSubscription = this.navService.movedToPreviousPage.subscribe(function () {
            _this.onMovePrevious.emit();
        });
        this.cancelSubscription = this.navService.notifyWizardCancel.subscribe(function () {
            _this.checkAndCancel();
        });
        this.wizardFinishedSubscription = this.navService.wizardFinished.subscribe(function () {
            _this.wizardFinished.emit();
            if (!_this.stopNext) {
                _this.forceFinish();
            }
        });
        this.differ = differs.find([]).create(null);
    }
    Object.defineProperty(Wizard.prototype, "stopModalAnimations", {
        get: function () {
            if (this._stopModalAnimations) {
                return "true";
            }
            return "false";
        },
        enumerable: true,
        configurable: true
    });
    Wizard.prototype.ngOnInit = function () {
        var _this = this;
        var navService = this.navService;
        this.currentPageSubscription = navService.currentPageChanged.subscribe(function (page) {
            _this.setGhostPages();
            _this.currentPageChanged.emit();
        });
    };
    Wizard.prototype.ngOnDestroy = function () {
        this.goNextSubscription.unsubscribe();
        this.goPreviousSubscription.unsubscribe();
        this.cancelSubscription.unsubscribe();
        this.currentPageSubscription.unsubscribe();
        this.wizardFinishedSubscription.unsubscribe();
    };
    Wizard.prototype.ngAfterContentInit = function () {
        this.pageCollection.pages = this.pages;
        this.navService.wizardHasAltCancel = this.stopCancel;
        this.navService.wizardHasAltNext = this.stopNext;
        this.headerActionService.wizardHeaderActions = this.headerActions;
        if (this.showGhostPages) {
            this.navService.hideWizardGhostPages = false;
            this.deactivateGhostPages();
        }
    };
    Wizard.prototype.ngDoCheck = function () {
        var _this = this;
        var changes = this.differ.diff(this.pages);
        if (changes) {
            changes.forEachAddedItem(function (r) {
                _this.navService.updateNavigation();
            });
            changes.forEachRemovedItem(function (r) {
                _this.navService.updateNavigation();
            });
        }
    };
    Object.defineProperty(Wizard.prototype, "isStatic", {
        get: function () {
            return this.elementRef.nativeElement.classList.contains("clr-wizard--inline");
            // SPECME
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "currentPage", {
        // The current page
        get: function () {
            return this.navService.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "isLast", {
        // LEGACY: convenience function to match legacy API
        get: function () {
            return this.navService.currentPageIsLast;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "isFirst", {
        // LEGACY: convenience function to match legacy API
        get: function () {
            return this.navService.currentPageIsFirst;
        },
        enumerable: true,
        configurable: true
    });
    // This is a public function that can be used to programmatically open the
    // wizard.
    // LEGACY: Naming convention matches old wizard
    Wizard.prototype.open = function () {
        var navService = this.navService;
        this._open = true;
        if (!this.currentPage) {
            navService.setFirstPageCurrent();
        }
        this.setGhostPages();
        this._openChanged.emit(true);
    };
    // This is a public function that can be used to programmatically close the
    // wizard.
    // LEGACY: Naming convention matches old wizard
    Wizard.prototype.close = function () {
        this._open = false;
        this.deactivateGhostPages();
        this._openChanged.emit(false);
    };
    // Convenience function that can be used to programmatically toggle the
    // wizard.
    Wizard.prototype.toggle = function (value) {
        if (value) {
            this.open();
        }
        else {
            this.close();
        }
    };
    // prev -- DEPRECATED
    // calls previous(); kept here to avoid breaking change where unnecessary
    // LEGACY: Naming convention matches old wizard
    Wizard.prototype.prev = function () {
        this.previous();
    };
    // the following are convenience functions that are carried over from an older
    // implementation of the wizard. They have been preserved so as not to create
    // a breaking change.
    Wizard.prototype.previous = function () {
        this.navService.previous();
    };
    // LEGACY: Naming convention matches old wizard
    Wizard.prototype.next = function () {
        this.navService.next();
    };
    Wizard.prototype.finish = function () {
        this.navService.finish();
    };
    // does the work of finishing up the wizard and closing it but
    // doesn't do the checks and emissions that other paths do.
    // good for a last step in an alternate workflow
    Wizard.prototype.forceFinish = function () {
        this.deactivateGhostPages();
        this.close();
        // SPECME
    };
    // does the work of moving the wizard to the next page in the
    // flow without the checks and emissions needed elsewhere.
    // good for moving to the next page in an alternate workflow
    Wizard.prototype.forceNext = function () {
        this.navService.forceNext();
        // SPECME
    };
    Wizard.prototype.cancel = function () {
        this.navService.cancel();
    };
    // need to bust out some logic here because the modal openChange event is
    // messing up alt-cancel routines
    Wizard.prototype.modalCancel = function () {
        this.checkAndCancel();
        // SPECME
    };
    Wizard.prototype.checkAndCancel = function () {
        var currentPage = this.currentPage;
        var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
        currentPage.pageOnCancel.emit();
        if (!currentPageHasOverrides) {
            this.onCancel.emit();
        }
        // SPECME
        if (!this.stopCancel && !currentPageHasOverrides) {
            this.close();
        }
        // SPECME
    };
    Wizard.prototype.goTo = function (pageId) {
        if (!pageId) {
            return;
        }
        this.navService.goTo(pageId);
    };
    Wizard.prototype.reset = function () {
        this.pageCollection.reset();
        this.navService.setFirstPageCurrent();
        this.onReset.next();
    };
    Object.defineProperty(Wizard.prototype, "ghostPageState", {
        get: function () {
            return this.navService.wizardGhostPageState;
        },
        enumerable: true,
        configurable: true
    });
    Wizard.prototype.deactivateGhostPages = function () {
        this.setGhostPages("deactivate");
    };
    Wizard.prototype.setGhostPages = function (deactivateOrNot) {
        if (deactivateOrNot === void 0) { deactivateOrNot = ""; }
        var navService = this.navService;
        var ghostpageStates = GHOST_PAGE_ANIMATION.STATES;
        if (this.showGhostPages) {
            if (deactivateOrNot === "deactivate") {
                navService.wizardGhostPageState = ghostpageStates.NO_PAGES;
            }
            else if (navService.currentPageIsLast) {
                navService.wizardGhostPageState = ghostpageStates.LAST_PAGE;
            }
            else if (navService.currentPageIsNextToLast) {
                navService.wizardGhostPageState = ghostpageStates.NEXT_TO_LAST_PAGE;
            }
            else {
                navService.wizardGhostPageState = ghostpageStates.ALL_PAGES;
            }
        }
    };
    return Wizard;
}());
export { Wizard };
Wizard.decorators = [
    { type: Component, args: [{
                selector: "clr-wizard",
                providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                template: "\n      <!--\n      ~ Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.\n      ~ This software is released under MIT license.\n      ~ The full license information can be found in LICENSE in the root directory of this project.\n      -->\n\n      <clr-modal \n          [clrModalOpen]=\"_open\"\n          [clrModalSize]=\"size\"\n          [clrModalClosable]=\"closable\"\n          [clrModalStaticBackdrop]=\"true\"\n          [clrModalSkipAnimation]=\"stopModalAnimations\"\n          [clrModalGhostPageState]=\"ghostPageState\"\n          [clrModalOverrideScrollService]=\"isStatic\"\n          clrModalPreventClose=\"true\"\n          (clrModalAlternateClose)=\"modalCancel()\">\n\n          <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n              <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n              <clr-wizard-stepnav></clr-wizard-stepnav>\n          </nav>\n\n          <h3 class=\"modal-title\">\n              <span class=\"modal-title-text\">\n                  <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n              </span>\n\n              <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n                  <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                      <ng-content select=\"clr-wizard-header-action\"></ng-content>\n                  </div>\n                  <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                      <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n                  </div>\n              </div>\n          </h3>\n\n          <div class=\"modal-body\">\n              <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n                  <ng-content></ng-content>\n              </main>\n          </div>\n          <div class=\"modal-footer clr-wizard-footer\">\n              <div class=\"clr-wizard-footer-buttons\">\n                  <div *ngIf=\"!navService.currentPage.hasButtons\" class=\"clr-wizard-footer-buttons-wrapper\">\n                      <ng-content select=\"clr-wizard-button\"></ng-content>\n                  </div>\n                  <div *ngIf=\"navService.currentPage.hasButtons\" class=\"clr-wizard-footer-buttons-wrapper\">\n                      <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n                  </div>\n              </div>\n          </div>\n      </clr-modal>\n    ",
                host: {
                    "[class.clr-wizard]": "true",
                    "[class.wizard-md]": "size == 'md'",
                    "[class.wizard-lg]": "size == 'lg'",
                    "[class.wizard-xl]": "size == 'xl'",
                    "[class.lastPage]": "navService.currentPageIsLast",
                    "[class.clr-wizard--ghosted]": "showGhostPages"
                }
            },] },
];
/** @nocollapse */
Wizard.ctorParameters = function () { return [
    { type: WizardNavigationService, },
    { type: PageCollectionService, },
    { type: ButtonHubService, },
    { type: HeaderActionService, },
    { type: ElementRef, },
    { type: IterableDiffers, },
]; };
Wizard.propDecorators = {
    'size': [{ type: Input, args: ["clrWizardSize",] },],
    'showGhostPages': [{ type: Input, args: ["clrWizardShowGhostPages",] },],
    'closable': [{ type: Input, args: ["clrWizardClosable",] },],
    '_open': [{ type: Input, args: ["clrWizardOpen",] },],
    '_openChanged': [{ type: Output, args: ["clrWizardOpenChange",] },],
    'onCancel': [{ type: Output, args: ["clrWizardOnCancel",] },],
    'wizardFinished': [{ type: Output, args: ["clrWizardOnFinish",] },],
    'onReset': [{ type: Output, args: ["clrWizardOnReset",] },],
    'pages': [{ type: ContentChildren, args: [WizardPage,] },],
    'headerActions': [{ type: ContentChildren, args: [WizardHeaderAction,] },],
    'currentPageChanged': [{ type: Output, args: ["clrWizardCurrentPageChanged",] },],
    'onMoveNext': [{ type: Output, args: ["clrWizardOnNext",] },],
    'onMovePrevious': [{ type: Output, args: ["clrWizardOnPrevious",] },],
    'stopNext': [{ type: Input, args: ["clrWizardPreventDefaultNext",] },],
    'stopCancel': [{ type: Input, args: ["clrWizardPreventDefaultCancel",] },],
    '_stopModalAnimations': [{ type: Input, args: ["clrWizardPreventModalAnimation",] },],
};
//# sourceMappingURL=wizard.js.map