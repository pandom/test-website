/*
 * Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Injectable } from "@angular/core";
import { Subject } from "rxjs/Subject";
import { PageCollectionService } from "./page-collection";
import { ButtonHubService } from "./button-hub";
import { GHOST_PAGE_ANIMATION } from "../../modal/utils/ghost-page-animations";
var WizardNavigationService = (function () {
    function WizardNavigationService(pageCollection, buttonService) {
        var _this = this;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
        // lets other components subscribe to when the current page changes
        this._currentChanged = new Subject();
        this.navServiceLoaded = false;
        this._movedToNextPage = new Subject();
        this._wizardFinished = new Subject();
        // When called, the wizard will move to the prev page.
        // This is a public function that can be used to programmatically go back
        // to the previous step.
        this._movedToPreviousPage = new Subject();
        this._cancelWizard = new Subject();
        this.wizardHasAltCancel = false;
        this.wizardHasAltNext = false;
        this._wizardGhostPageState = GHOST_PAGE_ANIMATION.STATES.NO_PAGES;
        this._hideWizardGhostPages = true;
        this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
            var currentPage = _this.currentPage;
            if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                return;
            }
            currentPage.previousButtonClicked.emit(currentPage);
            if (!currentPage.preventDefault) {
                _this.previous();
            }
        });
        this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage("next");
        });
        this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage("danger");
        });
        this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage("finish");
        });
        this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
            _this.currentPage.customButtonClicked.emit(type);
        });
        this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
            if (_this.currentPage.preventDefault) {
                _this.currentPage.pageOnCancel.emit(_this.currentPage);
            }
            else {
                _this.cancel();
            }
            // SPECME
        });
        this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
            _this.setLastEnabledPageCurrent();
        });
    }
    WizardNavigationService.prototype.ngOnDestroy = function () {
        this.previousButtonSubscription.unsubscribe();
        this.nextButtonSubscription.unsubscribe();
        this.dangerButtonSubscription.unsubscribe();
        this.finishButtonSubscription.unsubscribe();
        this.customButtonSubscription.unsubscribe();
        this.cancelButtonSubscription.unsubscribe();
        this.pagesResetSubscription.unsubscribe();
    };
    Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
        get: function () {
            return this._currentChanged.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
        get: function () {
            // when the querylist of pages is empty. this is the first place it fails...
            if (!this.currentPage) {
                throw new Error("Current page does not exist. QueryList of pages is probably empty and should not be.");
            }
            return this.currentPage.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
        get: function () {
            return this.pageCollection.firstPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsNextToLast", {
        get: function () {
            return this.pageCollection.penultimatePage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
        get: function () {
            return this.pageCollection.lastPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.setCurrentPage = function (page) {
        this.currentPage = page;
        page.onLoad.emit(page.id);
        this._currentChanged.next(page);
    };
    Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
        get: function () {
            return this._movedToNextPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
        get: function () {
            return this._wizardFinished.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    // next --
    //
    // When called, after successful validation, the wizard will move to the
    // next page.
    // This is a public function that can be used to programmatically advance
    // the user to the next page.
    WizardNavigationService.prototype.next = function () {
        if (this.currentPageIsLast) {
            this.checkAndCommitCurrentPage("finish");
            return;
        }
        this.checkAndCommitCurrentPage("next");
        if (!this.wizardHasAltNext) {
            this._movedToNextPage.next(true);
        }
        // SPECME
    };
    WizardNavigationService.prototype.forceNext = function () {
        var currentPage = this.currentPage;
        var nextPage = this.pageCollection.getNextPage(currentPage);
        // catch errant null or undefineds that creep in
        if (!nextPage) {
            throw new Error("The wizard has no next page to go to.");
        }
        if (!currentPage.completed) {
            // this is a state that alt next flows can get themselves in...
            this.pageCollection.commitPage(currentPage);
        }
        this.setCurrentPage(nextPage);
        // SPECME
    };
    WizardNavigationService.prototype.checkAndCommitCurrentPage = function (buttonType) {
        var currentPage = this.currentPage;
        var iAmTheLastPage;
        var isNext;
        var isDanger;
        var isDangerNext;
        var isDangerFinish;
        var isFinish;
        if (!currentPage.readyToComplete) {
            return;
        }
        iAmTheLastPage = this.currentPageIsLast;
        isNext = buttonType === "next";
        isDanger = buttonType === "danger";
        isDangerNext = isDanger && !iAmTheLastPage;
        isDangerFinish = isDanger && iAmTheLastPage;
        isFinish = buttonType === "finish" || isDangerFinish;
        if (isFinish && !iAmTheLastPage) {
            return;
        }
        currentPage.primaryButtonClicked.emit(buttonType);
        if (isFinish) {
            currentPage.finishButtonClicked.emit(currentPage);
        }
        else if (isDanger) {
            currentPage.dangerButtonClicked.emit();
        }
        else if (isNext) {
            currentPage.nextButtonClicked.emit();
        }
        if (currentPage.stopNext || currentPage.preventDefault) {
            currentPage.onCommit.emit(currentPage.id);
            return;
        }
        if (isFinish || isDangerFinish) {
            this._wizardFinished.next();
        }
        if (this.wizardHasAltNext) {
            if (isNext || isDangerNext) {
                this._movedToNextPage.next(true);
            }
            // jump out here, no matter what type we're looking at
            return;
        }
        // all the alt paths have early returned. mark page as
        // completed.
        this.pageCollection.commitPage(currentPage);
        if (isNext || isDangerNext) {
            this.forceNext();
        }
        // SPECME
    };
    WizardNavigationService.prototype.finish = function () {
        this.checkAndCommitCurrentPage("finish");
    };
    Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
        get: function () {
            return this._movedToPreviousPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.previous = function () {
        var previousPage;
        if (this.currentPageIsFirst) {
            return;
        }
        previousPage = this.pageCollection.getPreviousPage(this.currentPage);
        if (!previousPage) {
            return;
        }
        this._movedToPreviousPage.next(true);
        this.setCurrentPage(previousPage);
    };
    Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
        get: function () {
            return this._cancelWizard.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.cancel = function () {
        this._cancelWizard.next();
    };
    WizardNavigationService.prototype.goTo = function (pageToGoToOrId) {
        var pageToGoTo;
        var currentPage;
        var myPages;
        var pagesToCheck;
        var okayToMove = true;
        myPages = this.pageCollection;
        if (typeof pageToGoToOrId === "string") {
            // we have an ID so we need to look up our page
            pageToGoTo = myPages.getPageById(pageToGoToOrId);
        }
        else {
            pageToGoTo = pageToGoToOrId;
        }
        currentPage = this.currentPage;
        if (pageToGoTo === currentPage) {
            return;
        }
        else {
            pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
        }
        pagesToCheck.forEach(function (page) {
            if (!okayToMove) {
                return;
            }
            if (!page.completed && !page.current) {
                okayToMove = false;
            }
        });
        if (!okayToMove) {
            return;
        }
        this.setCurrentPage(pageToGoTo);
    };
    WizardNavigationService.prototype.setLastEnabledPageCurrent = function () {
        var allPages = this.pageCollection.pagesAsArray;
        var lastCompletedPageIndex = null;
        allPages.forEach(function (page, index) {
            if (page.completed) {
                lastCompletedPageIndex = index;
            }
        });
        if (lastCompletedPageIndex === null) {
            // always is at least the first item...
            lastCompletedPageIndex = 0;
        }
        else if ((lastCompletedPageIndex + 1) < allPages.length) {
            lastCompletedPageIndex = lastCompletedPageIndex + 1;
        }
        this.setCurrentPage(allPages[lastCompletedPageIndex]);
    };
    // used to reset to the first page
    // TODO?: EASIEST WAY TO SOLVE IS TO HAVE A GENERIC INPUT TO RESET TO A SPECIFIC ID
    WizardNavigationService.prototype.setFirstPageCurrent = function () {
        this.setCurrentPage(this.pageCollection.pagesAsArray[0]);
    };
    Object.defineProperty(WizardNavigationService.prototype, "wizardGhostPageState", {
        get: function () {
            return this._wizardGhostPageState;
        },
        set: function (value) {
            if (this.hideWizardGhostPages) {
                this._wizardGhostPageState = GHOST_PAGE_ANIMATION.STATES.NO_PAGES;
            }
            else {
                this._wizardGhostPageState = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "hideWizardGhostPages", {
        get: function () {
            return this._hideWizardGhostPages;
        },
        set: function (value) {
            this._hideWizardGhostPages = value;
        },
        enumerable: true,
        configurable: true
    });
    WizardNavigationService.prototype.updateNavigation = function () {
        var toSetCurrent;
        var currentPageRemoved;
        this.pageCollection.updateCompletedStates();
        currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
        toSetCurrent = this.pageCollection.findFirstIncompletePage();
        this.setCurrentPage(toSetCurrent);
    };
    return WizardNavigationService;
}());
export { WizardNavigationService };
WizardNavigationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
WizardNavigationService.ctorParameters = function () { return [
    { type: PageCollectionService, },
    { type: ButtonHubService, },
]; };
//# sourceMappingURL=wizard-navigation.js.map