/*
 * Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, Input, Output, EventEmitter, ContentChild } from "@angular/core";
import { WizardNavigationService } from "./providers/wizard-navigation";
import { PageCollectionService } from "./providers/page-collection";
import { ButtonHubService } from "./providers/button-hub";
import { WizardPageTitleDirective } from "./directives/page-title";
import { WizardPageNavTitleDirective } from "./directives/page-navtitle";
import { WizardPageButtonsDirective } from "./directives/page-buttons";
import { WizardPageHeaderActionsDirective } from "./directives/page-header-actions";
var wizardPageIndex = 0;
var WizardPage = (function () {
    function WizardPage(navService, pageCollection, buttonService) {
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        // Next button disabled
        // LEGACY: Naming convention of input matches old wizard; this.nextDisabled has been
        // changed to this.nextStepDisabled
        this._nextStepDisabled = false;
        // Emitter for Next button and readyToComplete state changes.
        // Need to manually call it. Not automagically called.
        // TOBREAK: Naming convention does not match old wizard; supports default two-way binding instead
        this.nextStepDisabledChange = new EventEmitter();
        // Previous button disabled
        this._previousStepDisabled = false;
        this.previousStepDisabledChange = new EventEmitter();
        // overrides all actions from the page level, so you can use an alternate function for
        // validation or data-munging with an onCommit or onCancel
        this.preventDefault = false;
        // overrides cancel from the page level, so you can use an alternate function for
        // validation or data-munging with clrWizardPageOnCancel
        this._stopCancel = false;
        this.stopCancelChange = new EventEmitter();
        // overrides next from the page level, so you can use an alternate function for
        // validation or data-munging with clrWizardPageOnNext
        this._stopNext = false;
        // TODO: SHOULD USE A CUSTOM BUTTON INSTEAD. NOTE BREAKING CHANGE...
        // User can bind an event handler for onCommit of the main content
        // LEGACY: Naming convention matches old wizard
        this.onCommit = new EventEmitter(false);
        // User can bind an event handler for onLoad of the main content
        // LEGACY: Naming convention matches old wizard
        this.onLoad = new EventEmitter();
        // This output can subvert the default cancel routine at the page level, if
        // used with clrWizardPagePreventDefaultCancel.
        // You will need to execute actual cancel from your event handler at some point
        // because this is a full replacement of the cancel functionality, not a detour.
        this.pageOnCancel = new EventEmitter();
        this.finishButtonClicked = new EventEmitter();
        this.previousButtonClicked = new EventEmitter();
        this.nextButtonClicked = new EventEmitter();
        this.dangerButtonClicked = new EventEmitter();
        this.primaryButtonClicked = new EventEmitter();
        this.customButtonClicked = new EventEmitter();
        // If our host has an ID attribute, we use this instead of our index.
        // sometimes people are using array indices here. that's why it's "any".
        // most often a string or a number.
        this._id = (wizardPageIndex++).toString();
        this._complete = false;
    }
    Object.defineProperty(WizardPage.prototype, "nextStepDisabled", {
        get: function () {
            return this._nextStepDisabled;
        },
        set: function (val) {
            var valBool = !!val;
            if (valBool !== this._nextStepDisabled) {
                this._nextStepDisabled = valBool;
                //TODO: SHOULD WE UPDATE PREVIOUS/NEXT STEPS WHEN THIS IS CHANGED? OR RELY ON USERS TO DO IT?
                this.nextStepDisabledChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "previousStepDisabled", {
        get: function () {
            return this._previousStepDisabled;
        },
        set: function (val) {
            var valBool = !!val;
            if (valBool !== this._previousStepDisabled) {
                this._previousStepDisabled = valBool;
                this.previousStepDisabledChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "stopCancel", {
        get: function () {
            return this._stopCancel;
        },
        set: function (val) {
            var valBool = !!val;
            if (valBool !== this._stopCancel) {
                this._stopCancel = valBool;
                this.stopCancelChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "stopNext", {
        get: function () {
            return this._stopNext;
        },
        set: function (val) {
            var valBool = !!val;
            if (valBool !== this._stopNext) {
                this._stopNext = valBool;
            }
            // SPECME
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "id", {
        get: function () {
            // covers things like null, undefined, false, and empty string
            // while allowing zero to pass
            var idIsNonZeroFalsy = (!this._id && this._id !== 0);
            // in addition to non-zero falsy we also want to make sure _id is not a negative
            // number.
            if (idIsNonZeroFalsy || this._id < 0) {
                // guard here in the event that input becomes undefined or null by accident
                this._id = (wizardPageIndex++).toString();
            }
            return "clr-wizard-page-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "readyToComplete", {
        get: function () {
            return !this.nextStepDisabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "completed", {
        get: function () {
            return this._complete && this.readyToComplete;
            // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
            // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
            // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
            // FIRST QUESTION: AM I GREY OR COLORED?
            // SECOND QUESTION: AM I GREEN OR RED?
        },
        set: function (value) {
            this._complete = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "current", {
        // asks navService if it is the currentPage
        get: function () {
            return this.navService.currentPage === this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "disabled", {
        get: function () {
            return !this.enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "enabled", {
        get: function () {
            return this.current || this.completed || this.previousCompleted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "previousCompleted", {
        get: function () {
            var previousPage = this.pageCollection.getPreviousPage(this);
            if (!previousPage) {
                return true;
            }
            return previousPage.completed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "title", {
        // TOBREAK: this is now a templateRef and no longer a string
        get: function () {
            return this.pageTitle.pageTitleTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "navTitle", {
        get: function () {
            if (this.pageNavTitle) {
                return this.pageNavTitle.pageNavTitleTemplateRef;
            }
            return this.pageTitle.pageTitleTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "headerActions", {
        get: function () {
            if (!this._headerActions) {
                return;
            }
            return this._headerActions.pageHeaderActionsTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "hasHeaderActions", {
        get: function () {
            return !!this._headerActions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "buttons", {
        get: function () {
            if (!this._buttons) {
                return;
            }
            return this._buttons.pageButtonsTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardPage.prototype, "hasButtons", {
        get: function () {
            return !!this._buttons;
        },
        enumerable: true,
        configurable: true
    });
    WizardPage.prototype.makeCurrent = function () {
        this.navService.setCurrentPage(this);
    };
    WizardPage.prototype.ngOnInit = function () {
        var navService = this.navService;
        if (!navService.currentPage && !navService.navServiceLoaded) {
            this.makeCurrent();
            this.navService.navServiceLoaded = true;
        }
    };
    Object.defineProperty(WizardPage.prototype, "stepItemId", {
        get: function () {
            return this.pageCollection.getStepItemIdForPage(this);
        },
        enumerable: true,
        configurable: true
    });
    return WizardPage;
}());
export { WizardPage };
WizardPage.decorators = [
    { type: Component, args: [{
                selector: "clr-wizard-page",
                template: "<ng-content></ng-content>",
                host: {
                    "[id]": "id",
                    "role": "tabpanel",
                    "[attr.aria-hidden]": "!current",
                    "[attr.aria-labelledby]": "stepItemId",
                    "[class.active]": "current",
                    "[class.clr-wizard-page]": "true"
                }
            },] },
];
/** @nocollapse */
WizardPage.ctorParameters = function () { return [
    { type: WizardNavigationService, },
    { type: PageCollectionService, },
    { type: ButtonHubService, },
]; };
WizardPage.propDecorators = {
    'pageTitle': [{ type: ContentChild, args: [WizardPageTitleDirective,] },],
    'pageNavTitle': [{ type: ContentChild, args: [WizardPageNavTitleDirective,] },],
    '_buttons': [{ type: ContentChild, args: [WizardPageButtonsDirective,] },],
    '_headerActions': [{ type: ContentChild, args: [WizardPageHeaderActionsDirective,] },],
    'nextStepDisabled': [{ type: Input, args: ["clrWizardPageNextDisabled",] },],
    'nextStepDisabledChange': [{ type: Output, args: ["clrWizardPageNextDisabledChange",] },],
    'previousStepDisabled': [{ type: Input, args: ["clrWizardPagePreviousDisabled",] },],
    'previousStepDisabledChange': [{ type: Output, args: ["clrWizardPagePreviousDisabledChange",] },],
    'preventDefault': [{ type: Input, args: ["clrWizardPagePreventDefault",] },],
    'stopCancel': [{ type: Input, args: ["clrWizardPagePreventDefaultCancel",] },],
    'stopCancelChange': [{ type: Output, args: ["clrWizardPagePreventDefaultCancelChange",] },],
    'stopNext': [{ type: Input, args: ["clrWizardPagePreventDefaultNext",] },],
    'onCommit': [{ type: Output, args: ["clrWizardPageOnCommit",] },],
    'onLoad': [{ type: Output, args: ["clrWizardPageOnLoad",] },],
    'pageOnCancel': [{ type: Output, args: ["clrWizardPageOnCancel",] },],
    'finishButtonClicked': [{ type: Output, args: ["clrWizardPageFinish",] },],
    'previousButtonClicked': [{ type: Output, args: ["clrWizardPagePrevious",] },],
    'nextButtonClicked': [{ type: Output, args: ["clrWizardPageNext",] },],
    'dangerButtonClicked': [{ type: Output, args: ["clrWizardPageDanger",] },],
    'primaryButtonClicked': [{ type: Output, args: ["clrWizardPagePrimary",] },],
    'customButtonClicked': [{ type: Output, args: ["clrWizardPageCustomButton",] },],
    '_id': [{ type: Input, args: ["id",] },],
};
//# sourceMappingURL=wizard-page.js.map